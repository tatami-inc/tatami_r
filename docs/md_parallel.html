<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami_r: Enabling parallelization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami_r
   </div>
   <div id="projectbrief">R bindings to tatami matrices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Enabling parallelization</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md5"></a></p>
<h1><a class="anchor" id="autotoc_md6"></a>
Overview</h1>
<p>By default, we assume that the <code><a class="el" href="classtatami__r_1_1UnknownMatrix.html" title="Unknown matrix-like object in R.">tatami_r::UnknownMatrix</a></code> will only be used in a single-threaded context. This is because the <code>UnknownMatrix</code> methods will call the R API, which is strictly single-threaded. In fact, it's worse than that: some experimentation indicates that R code can only be executed on the main thread. Otherwise, we get stack limit errors when R is called inside a worker, even with locking to enforce serial execution. I suspect that some other R-managed process (an event loop, perhaps?) is always running on the main thread; calling R from the worker will fail to block this process and lead to parallel execution between the worker and the main threads.</p>
<p>That said, it is possible to use <code>UnknownMatrix</code> objects in a parallel context with some effort. Using the <a href="https://github.com/tatami-inc/manticore"><b>manticore</b></a> library, each worker thread can pass a function for execution on the main thread. Specifically, multiple workers can request execution of the various <code>extract_*_array()</code> functions on the main thread; once this is done, the extracted data is converted into something independent of R and returned to the worker. Our assumption is that most of each worker's time is spent computing on the extracted data rather than waiting on the main thread, such that parallelization still offers some performance improvement.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Parallelizing matrix iterations</h1>
<p>We provide a <code><a class="el" href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize()</a></code> function that handles all of the <b>manticore</b>-related boilerplate. The <code>UnknownMatrix</code> methods will safely run within the lambda passed to this function.</p>
<div class="fragment"><div class="line"><span class="comment">// Must be defined before including tatami_r/parallelize.hpp</span></div>
<div class="line"><span class="preprocessor">#define TATAMI_R_PARALLELIZE_UNKNOWN </span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parallelize_8hpp.html">tatami_r/parallelize.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize</a>([&amp;](<span class="keywordtype">size_t</span> thread_id, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> len) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="comment">// Do something with the UnknownMatrix.</span></div>
<div class="line">    <span class="keyword">auto</span> ext = ptr-&gt;dense_row();</div>
<div class="line">    std::vector&lt;double&gt; buffer(ptr-&gt;ncol());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = start, end = start + len; start &lt; end; ++r) {</div>
<div class="line">        <span class="keyword">auto</span> out = ext-&gt;fetch(r, buffer.data());</div>
<div class="line">        <span class="comment">// Do something with each row.</span></div>
<div class="line">    }</div>
<div class="line">}, ptr-&gt;nrow(), num_threads);</div>
<div class="ttc" id="anamespacetatami__r_html_a568468e7f0930d3abe1493cd0164b0aa"><div class="ttname"><a href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize</a></div><div class="ttdeci">void parallelize(Function_ fun, Index_ njobs, int nthreads)</div><div class="ttdef"><b>Definition</b> parallelize.hpp:61</div></div>
<div class="ttc" id="aparallelize_8hpp_html"><div class="ttname"><a href="parallelize_8hpp.html">parallelize.hpp</a></div><div class="ttdoc">Safely parallelize for unknown matrices.</div></div>
</div><!-- fragment --><p><code><a class="el" href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize()</a></code> can also be used as a custom <b>tatami</b> parallelization scheme. This requires a little bit of care as the <code>TATAMI_CUSTOM_PARALLEL</code> macro has to be set before any includes of <b>tatami</b>... which itself is included by all <b><a class="el" href="namespacetatami__r.html" title="tatami bindings for arbitrary R matrices.">tatami_r</a></b> headers except for <code>parallelize.hpp</code>, so it's easy to get wrong! We suggest using the following sequence of preprocessor statements before any <b>tatami</b>-containing source file. (If using <a href="https://github.com/tatami-inc/beachmat"><b>beachmat</b></a>'s <code>Rtatami.h</code> header, all of these preprocessor statements have already been added for our convenience.)</p>
<div class="fragment"><div class="line"><span class="comment">// Must be defined before including tatami_r/parallelize.hpp</span></div>
<div class="line"><span class="preprocessor">#define TATAMI_R_PARALLELIZE_UNKNOWN </span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parallelize_8hpp.html">tatami_r/parallelize.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defining the tatami parallelization scheme, which must </span></div>
<div class="line"><span class="comment">// occur before including tatami or tatami_r itself.</span></div>
<div class="line"><span class="preprocessor">#define TATAMI_CUSTOM_PARALLEL tatami_r::parallelize</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tatami__r_8hpp.html">tatami_r/tatami_r.hpp</a>&quot;</span></div>
<div class="ttc" id="atatami__r_8hpp_html"><div class="ttname"><a href="tatami__r_8hpp.html">tatami_r.hpp</a></div><div class="ttdoc">tatami bindings for arbitrary R matrices.</div></div>
</div><!-- fragment --><p>We can now use <code><a class="elRef" href="https://tatami-inc.github.io/tatami/namespacetatami.html#a5a08e0387bc00e8045a0364d6e35d120">tatami::parallelize()</a></code>, <code>TATAMI_CUSTOM_PARALLEL</code> and <code><a class="el" href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize()</a></code> interchangeably.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Using the main thread executor</h1>
<p>We can perform our own calls to the R API inside each worker by wrapping it in the <b>manticore</b> executor. This will execute the user-provided function on the main thread before returning control to the worker. Developers do not have to do the usual <b>manticore</b> dance of <code>initialize()</code>, <code>listen()</code>, <code>finish_thread()</code>, and so on; this is all handled by <code><a class="el" href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize()</a></code> itself, so only <code>run()</code> needs to be specified.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; mexec = <a class="code hl_function" href="namespacetatami__r.html#a7cbde3ef2a02ed9a8d84ecd89697eb58">tatami_r::executor</a>();</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize</a>([&amp;](<span class="keywordtype">size_t</span> thread_id, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> len) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    mexec.run([&amp;]() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">        <span class="comment">// Do something that touches the R API.</span></div>
<div class="line">    });</div>
<div class="line">}, ptr-&gt;nrow(), num_threads);</div>
<div class="ttc" id="anamespacetatami__r_html_a7cbde3ef2a02ed9a8d84ecd89697eb58"><div class="ttname"><a href="namespacetatami__r.html#a7cbde3ef2a02ed9a8d84ecd89697eb58">tatami_r::executor</a></div><div class="ttdeci">manticore::Executor &amp; executor()</div><div class="ttdef"><b>Definition</b> parallelize.hpp:34</div></div>
</div><!-- fragment --><p>It is important to use the global executor provided by the <code><a class="el" href="namespacetatami__r.html#a7cbde3ef2a02ed9a8d84ecd89697eb58">tatami_r::executor()</a></code> function, as this is the same as that used inside <code><a class="el" href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize()</a></code>. Otherwise, if a different <code>manticore::Executor</code> instance is created, we will not be properly protected from simultaneous calls to the R API from different workers.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Under the hood</h1>
<p>Assume that we already have a <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a></code> object that <em>might</em> contain a <code>UnknownMatrix</code>. To enable safe parallel execution, we call <code>initialize()</code> before the parallel section and <code>listen()</code> afterwards. This diverts the R code to the main thread for execution while allowing all other <b>tatami</b>-related code to run inside each worker. Note that users must define the <code>TATAMI_R_PARALLELIZE_UNKNOWN</code> macro to expose the <code>executor()</code> function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define TATAMI_R_PARALLELIZE_UNKNOWN</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initializing the context with a manticore::Executor.</span></div>
<div class="line"><span class="keyword">auto</span>&amp; mexec = <a class="code hl_function" href="namespacetatami__r.html#a7cbde3ef2a02ed9a8d84ecd89697eb58">tatami_r::executor</a>();</div>
<div class="line">mexec.initialize(num_threads);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spin up std::thread objects. You can actually use anything</span></div>
<div class="line"><span class="comment">// that respects &lt;mutex&gt;, &lt;atomic&gt; and &lt;condition_variable&gt;.</span></div>
<div class="line">std::vector&lt;std::thread&gt; threads;</div>
<div class="line">threads.reserve(num_threads);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> t = 0; t &lt; num_threads; ++t) {</div>
<div class="line">    threads.emplace_back([&amp;]() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">        <span class="comment">// Do something with the tatami:Matrix here.</span></div>
<div class="line">        <span class="keyword">auto</span> wrk = my_matrix-&gt;dense_row();</div>
<div class="line">        <span class="keyword">auto</span> row_t = wrk-&gt;fetch(t);</div>
<div class="line">        mexec.finish_thread();</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Listen for requests from the worker threads.</span></div>
<div class="line">mexec.listen();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Join all threads once the work is done.</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; th : threads) {</div>
<div class="line">    th.join();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Check out the implementation of <code><a class="el" href="namespacetatami__r.html#a568468e7f0930d3abe1493cd0164b0aa">tatami_r::parallelize()</a></code> for more details.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Further comments</h1>
<p>Note that construction of the <code>UnknownMatrix</code> must always be performed on the main thread. This is because construction of the unknown fallback involves some calls into the R runtime; these are currently not protected from execution in worker contexts. Similarly, any <b>Rcpp</b>-based allocations - even default construction of classes like <code>Rcpp::NumericVector</code> - should be done in the main thread, just in case. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
